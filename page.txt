"Java  \n\nКласс языка\n\nмультипарадигмальный язык программирования, язык JVM[d] и язык программирования\n\n\nПоявился в\n\n23 мая 1995\n\n\nАвтор\n\nДжеймс Гослинг и Sun Microsystems\n\n\nРазработчик\n\nSun Microsystems и Oracle\n\n\nРасширение файлов\n\n.java, .class или .jar\n\n\nВыпуск\n\nJava Standard Edition 10 1 \n\n\nИспытал влияние\n\nC++, Си, Ада, Simula 67[d , Smalltalk, Objective-C, Object Pascal, Оберон, Eiffel, Модула-3, Mesa[d , Симула, C#, UCSD Pascal, обёртка, Вариативная функция, аннотация Java, Никлаус Вирт, Patrick Naughton[d] и foreach[d \n\n\nЛицензия\n\nGNU GPL и Java Community Process\n\n\nСайт\n\njava.com  (англ.)\n\n\nЭта статья — о языке программирования. О прикладной платформе на основе данного языка см. Java (программная платформа).\nJava прим. 1  — строго типизированный объектно-ориентированный язык программирования, разработанный компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process, язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.\nПриложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация виртуальной Java-машины. Дата официального выпуска — 23 мая 1995 года. На 2019 год Java — один из самых популярных языков программирования 2  3 .\n\nСодержание\n\n1 История создания\n2 Основные особенности языка\n3 История версий\n\n3.1 JDK 1.0\n3.2 JDK 1.1\n3.3 J2SE 1.2\n3.4 J2SE 1.3\n3.5 J2SE 1.4\n3.6 J2SE 5.0\n3.7 Java SE 6\n3.8 Java FX\n3.9 Java ME Embedded\n3.10 Java SE 7\n\n3.10.1 Список нововведений\n\n\n3.11 Java SE 8\n\n3.11.1 Список нововведений\n\n\n3.12 Java SE 9\n\n3.12.1 Список нововведений\n\n\n3.13 Java SE 10\n\n3.13.1 Список нововведений\n\n\n3.14 Java SE 11\n\n3.14.1 Список нововведений\n\n\n\n\n4 Классификация платформ Java\n5 Java и Microsoft\n6 Java и Android\n7 Применения платформы Java\n\n7.1 Производительность\n\n\n8 Основные возможности\n9 Основные идеи\n\n9.1 Примитивные типы\n\n9.1.1 Преобразования при математических операциях\n\n\n9.2 Объектные переменные, объекты, ссылки и указатели\n\n9.2.1 Дублирование ссылок и клонирование\n9.2.2 Инициализация переменных\n9.2.3 Сборка мусора\n\n\n9.3 Классы и функции\n\n9.3.1 Конструкторы\n9.3.2 Статические методы и поля\n9.3.3 Завершённость (final)\n9.3.4 Абстрактность\n9.3.5 Интерфейсы\n\n9.3.5.1 Маркерные интерфейсы\n\n\n9.3.6 Шаблоны в Java (generics)\n9.3.7 Проверка принадлежности к классу\n\n\n9.4 Обработка ошибок\n9.5 Пространство имён\n\n\n10 Примеры программ\n11 Средства разработки ПО\n12 См. также\n13 Примечания\n\n13.1 Комментарии\n13.2 Документация\n13.3 Источники\n\n\n14 Литература\n15 Ссылки\n\n\n\nИстория создания\nИзначально язык назывался Oak («Дуб»), разрабатывался Джеймсом Гослингом для программирования бытовых электронных устройств. Из-за того, что язык с таким названием уже существовал, вскоре Oak был переименован в Java 4 . Назван в честь марки кофе Java, которая, в свою очередь, получила наименование одноимённого острова (Ява), поэтому на официальной эмблеме языка изображена чашка с горячим кофе. Существует и другая версия происхождения названия языка, связанная с аллюзией на кофе-машину как пример бытового устройства, для программирования которого изначально язык создавался. В соответствии с этимологией в русскоязычной литературе с конца двадцатого и до первых лет двадцать первого века название языка нередко переводилось как Ява, а не транскрибировалось.\nВ результате работы проекта мир увидел принципиально новое устройство, которое опередило своё время более чем на 10 лет. Устройство получило название Star7, но из-за большой стоимости в 50 долларов не смогло произвести переворот в мире технологии и постепенно забылось.\nStar7 не пользовался популярностью в отличие от языка программирования Java и его окружения. Следующим этапом жизни языка стала разработка интерактивного телевидения. В 1994 году стало очевидным, что интерактивное телевидение было ошибкой.\nС середины 1990-х годов язык стал широко использоваться для написания клиентских приложений и серверного программного обеспечения. Тогда же определённое распространение получила технология Java-апплетов — графических Java-приложений, встраиваемых в веб-страницы; с развитием возможностей динамических веб-страниц в 2000-е годы технология стала применяться редко.\n\nОсновные особенности языка\nПрограммы на Java транслируются в байт-код Java, выполняемый виртуальной машиной Java (JVM) — программой, обрабатывающей байтовый код и передающей инструкции оборудованию как интерпретатор.\n\n  Дюк — талисман Java\nДостоинством подобного способа выполнения программ является полная независимость байт-кода от операционной системы и оборудования, что позволяет выполнять Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Другой важной особенностью технологии Java является гибкая система безопасности, в рамках которой исполнение программы полностью контролируется виртуальной машиной. Любые операции, которые превышают установленные полномочия программы (например, попытка несанкционированного доступа к данным или соединения с другим компьютером), вызывают немедленное прерывание.\nЧасто к недостаткам концепции виртуальной машины относят снижение производительности. Ряд усовершенствований несколько увеличил скорость выполнения программ на Java:\n\nприменение технологии трансляции байт-кода в машинный код непосредственно во время работы программы (JIT-технология) с возможностью сохранения версий класса в машинном коде,\nобширное использование платформенно-ориентированного кода (native-код) в стандартных библиотеках,\nаппаратные средства, обеспечивающие ускоренную обработку байт-кода (например, технология Jazelle, поддерживаемая некоторыми процессорами архитектуры ARM).\nПо данным сайта shootout.alioth.debian.org, для семи разных задач время выполнения на Java составляет в среднем в полтора-два раза больше, чем для C/C++, в некоторых случаях Java быстрее, а в отдельных случаях в 7 раз медленнее 5 . С другой стороны, для большинства из них потребление памяти Java-машиной было в 10—30 раз больше, чем программой на C/C++. Также примечательно исследование, проведённое компанией Google, согласно которому отмечается существенно более низкая производительность и бо́льшее потребление памяти в тестовых примерах на Java в сравнении с аналогичными программами на C++ 6  7  8 .\nИдеи, заложенные в концепцию и различные реализации среды виртуальной машины Java, вдохновили множество энтузиастов на расширение перечня языков, которые могли бы быть использованы для создания программ, исполняемых на виртуальной машине 9 . Эти идеи нашли также выражение в спецификации общеязыковой инфраструктуры CLI, заложенной в основу платформы .NET компанией Microsoft.\n\nИстория версий\nОсновная статья: История версий Java\nJDK 1.0\nРазработка Java началась в 1990 году, первая официальная версия — Java 1.0, — была выпущена только 21 января 1996 года.\n\nJDK 1.1\nВторая версия была выпущена 19 февраля 1997 года 10 .\n\nБиблиотека Accessibility.\nJava 2D.\nПоддержка технологии drag-and-drop.\nПолная поддержка Unicode, включая поддержку ввода на японском, китайском и корейском языках.\nПоддержка воспроизведения аудиофайлов нескольких популярных форматов.\nПолная поддержка технологии CORBA.\nJIT-компилятор, улучшенная производительность.\nУсовершенствования инструментальных средств JDK, в том числе поддержка профилирования Java-программ.\nJ2SE 1.2\nДата выпуска 8 декабря 1998 года 11 . Кодовое имя Playground.\nВ данном случае встречается путаница. Выпускались книги, например, Beginning Java 2 by Ivor Horton (Mar 1999), фактически по J2SE 1.2 (бывшее название — Java 2). Вместе с тем по сей день такие книги публикуются, например: Х. М. Дейтел, П. Дж. Дейтел, С. И. Сантри. Технологии программирования на Java 2. Распределённые приложения (2011).\nВ то время, когда, как известно, Java 2 была исторически заменена следующими релизами, подобные названия книг дезориентируют в понимании, о какой же версии Java они написаны на самом деле. Если J2SE 1.2 принято считать за Java 2, а авторы книг за Java 2 принимают JDK 7, это приводит к полной путанице.\n\nJ2SE 1.3\nДата выпуска 8 мая 2000 года. Кодовое имя Kestrel.\n\nJ2SE 1.4\nДата выпуска 6 февраля 2002 года. Кодовое имя Merlin.\n\nJ2SE 5.0\nСпецификация Java 5.0 была выпущена 30 сентября 2004 года, кодовое имя Tiger. C этой версии изменена официальная индексация, вместо Java 1.5 правильнее называть Java 5.0. Внутренняя же индексация Sun осталась прежней — 1.x. Минорные изменения теперь включаются без изменения индексации, для этого используется слово «Update» или буква «u», например, Java Development Kit 5.0 Update 22. Предполагается, что в обновления могут входить как исправления ошибок, так и небольшие добавления в API, JVM.\nВ данной версии разработчики внесли в язык целый ряд принципиальных дополнений:\n\nПеречислимые типы (англ. enum). Ранее отсутствовавшие в Java типы оформлены по аналогии с C++, но при этом имеют ряд дополнительных возможностей.\nПеречислимый тип является полноценным классом Java, то есть может иметь конструктор, поля, методы, в том числе скрытые и абстрактные.\nПеречисление может реализовывать интерфейсы.\nДля перечислений имеются встроенные методы, дающие возможность получения значений типа по имени, символьных значений, соответствующих именам, преобразования между номером и значением, проверки типа на то, что он является перечислимым.\nАннотации — возможность добавления в текст программы метаданных, непосредственно не влияющих на выполнение кода, но допускающих использование для получения различных сведений о коде и его исполнении. Одновременно выпущен инструментарий для использования аннотированного кода. Одно из применений аннотаций — упрощение создания тестовых модулей для Java-кода.\nСредства обобщённого программирования (англ. generics) — механизм, аналогичный средствам языков Ada 12  и Eiffel (позже также появились и в C#, принципиально отличаются от шаблонов C++), дающий возможность создавать классы и методы с полями и параметрами произвольного объектного типа. С использованием данного механизма реализованы новые версии коллекций стандартной библиотеки Java.\nМетоды с неопределённым числом параметров.\nAutoboxing/Unboxing — автоматическое преобразование между скалярными типами Java и соответствующими типами-обёртками (например, между int — Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях.\nРазрешён импорт статических полей и методов.\nВ язык введён цикл по коллекции объектов (итератор, англ. foreach).\nБыло введено использование Javadoc-комментариев, которые используются для автоматического оформления документации по комментариям в исходном коде.\nJava SE 6\nРелиз версии состоялся 11 декабря 2006 года, кодовое имя Mustang. Изменена официальная индексация — вместо ожидаемой 6.0 версия значится как 6. Минорные изменения, как и в Java 5.0, вносятся в обычные обновления версии, например, Java Standard Edition Development Kit 6 Update 27. Внесены следующие изменения:\n\nКоллекции — добавлены интерфейсы для организации очереди, работающей с двух сторон коллекции; организовывающие поиск по ближайшему соответствию; блокирующие себя во время ожидания элемента. Организованы новые классы, реализующие перечисленные интерфейсы.\nДобавлена поддержка японского императорского календаря (наряду с уже существующими григорианским и буддийским календарями).\nДоступны классы-потоки для чтения и передачи сжатых данных, с возможностью передачи их по сети. Сняты ограничения на количество файлов в архиве (ранее 64 Кб), длину названия файла (ранее 256 символов) и количество одновременно открытых файлов (ранее 2000 шт).\nОрганизована система управления кэшем и добавлена поддержка параметра «no-cache» в HTTP-запросе.\nJConsole, графический мониторинг JVM, стала официально поддерживаемой утилитой.\nJava HTTP Server, позволяет создать полноценный HTTP-сервер, с минимально необходимыми функциональными свойствами.\nПовысилась скорость вычислений на 70 %, скорость операций ввода-вывода возросла в два раза 13 .\nSwing — улучшена работоспособность OpenGL и DirectX; обработка текста на LCD; добавлен GifWriter, для работы с файлами формата GIF.\nИсправлено большое количество ошибок.\nJava FX\nДата выпуска 8 октября 2013 года.\nJavaFX 2.2 вошёл в состав Java SE 7 update 6 14 . С 11-й версии модуль поставляется отдельно от JDK 15 .\n\nJava ME Embedded\nДата выпуска 10 октября 2013 года. Кодовое имя Micro Edition.\n\nJava SE 7\nРелиз версии состоялся 28 июля 2011 года, кодовое имя Dolphin 16 . В финальную версию Java Standard Edition 7 не были включены все ранее запланированные изменения. Согласно плану развития (план «Б») 17 , включение нововведений будет разбито на две части: Java Standard Edition 7 (без лямбда-исчисления, проекта Jigsaw, и части улучшений проекта Coin 18 ) и Java Standard Edition 8 (все остальное), намеченный на конец 2012 года.\nВ новой версии, получившей название Java Standard Edition 7 (Java Platform, Standard Edition 7), помимо исправления большого количества ошибок, было представлено несколько новшеств. Так, например, в качестве эталонной реализации Java Standard Edition 7 использован не проприетарный пакет JDK, а его открытая реализация OpenJDK, а сам релиз новой версии платформы готовился при тесном сотрудничестве инженеров Oracle с участниками мировой экосистемы Java, комитетом JCP (Java Community Process) и сообществом OpenJDK. Все поставляемые Oracle бинарные файлы эталонной реализации Java Standard Edition 7 собраны на основе кодовой базы OpenJDK, сама эталонная реализация полностью открыта под лицензией GPLv2 с исключениями GNU ClassPath, разрешающими динамическое связывание с проприетарными продуктами. К другим нововведениям относится интеграция набора небольших языковых улучшений Java, развиваемых в рамках проекта Coin, добавлена поддержка языков программирования с динамической типизацией, таких, как Ruby, Python и JavaScript, поддержка загрузки классов по URL, обновлённый XML-стек, включающий JAXP 1.4, JAXB 2.2a и JAX-WS 2.2 и другие 19 .\nЗа 5 дней до выхода релиза Java Standard Edition 7 было обнаружено несколько серьёзных ошибок в горячей оптимизации циклов, которая включена по умолчанию и приводит виртуальную машину Java к краху. Специалисты Oracle найденные ошибки за столь короткий срок исправить не могли, но пообещали, что они будут исправлены во втором обновлении (Java 7 Update 2) и частично в первом 20 .\n\nСписок нововведений\nПоддержка динамически-типизированных языков (InvokeDynamic) — расширение JVM (семантики байт-кода), языка Java 21  для поддержки динамически-типизированных языков.\nСтрогая проверка class-файлов — class-файлы версии 51 (Java Standard Edition 7) или более поздней версии должны быть проверены typechecking-верификатором; JVM не должна переключаться на старый верификатор.\nИзменение синтаксиса языка Java (Project Coin) — частичные изменения в языке Java, предназначенные для упрощения общих задач программирования:\nИспользование класса String док. 1  в блоке switch.\nЗакрытие используемых ресурсов в блоке try (try-with-resources) — работает при использовании интерфейса AutoClosable док. 2 .\nОбъединённая обработка исключений в блоке catch (multi-catch exceptions) — перечисление обрабатываемых исключений в catch (… | … | …).\nПовторное выбрасывание исключений (rethrowing exceptions) — передача возникшего исключения «вверх» по стеку вызовов.\nПодчёркивания в числовых литералах для лучшего восприятия больших чисел.\nИзменение вывода типа в Java generic при создании объекта.\nИспользование двоичных чисел (binary literals) — префикс 0b укажет, что используется двоичное число.\nУпрощение вызова методов varargs — уменьшение предупреждений при вызове метода с переменным числом входящих переменных.\nМодификация загрузчика классов (class-loader) — избежание тупиковых ситуаций в неиерархической топологии загрузки классов.\nЗакрытие ресурсов, открытых URLClassLoader док. 3 .\nОбновление коллекций (JSR 166).\nПоддержка Unicode 6.0.\nОтделение языка пользователя и языка пользовательского интерфейса — обновление обработки языков для отделения локали от языка пользовательского интерфейса.\nНовые интерфейсы I/O для платформы Java (nio.2).\nИспользование JDBC 4.1 и Rowset 1.1.\n… (не закончено)\nJava SE 8\nРелиз версии состоялся 19 марта 2014 года. Кодовое имя Octopus.\n\nСписок нововведений\nПолноценная поддержка лямбда-выражений.\nКлючевое слово default в интерфейсах для поддержки функциональности по умолчанию.\nСтатические методы в интерфейсах.\nСсылки на методы и конструкторы 22  23 .\nФункциональные интерфейсы (предикаты, поставщики и т. д.)\nПотоки (stream) для работы с коллекциями.\nНовый API для работы с датами.\n… (не закончено)\nJava SE 9\nВ связи со сложностями в реализации модульной системы в рамках проекта Jigsaw, релиз версии, первоначально запланированный 22 сентября 2016 года, несколько раз откладывался: сначала дата была перенесена на 23 марта 2017 года, потом — на 27 июля 2017 года, а затем — на 21 сентября 2017 года 24  25  26 .\nПоследняя дата стала официальной датой релиза версии 27 .\n\nСписок нововведений\nИнтеграция Jigsaw, в рамках которого разработана модульная система для платформы Java 9 и применена к JDK 9 28 .\nОбновление Process API для улучшения взаимодействия с процессами операционной системы. Обновление мотивировано тем, что разработчикам зачастую приходилось писать платформозависимый код для таких задач 29 .\nВременно экспериментальный 30  31  новый HTTP-клиент с поддержкой HTTP/2 и веб-сокетов; предназначен заменить устаревший класс HttpURLConnection док. 4  30 .\nСжатые строки: если содержимое строки позволяет, она может кодироваться в Latin-1 (один байт на символ); выбор кодировки конкретного экземпляра класса String отображается в значении переменной-флага, которая теперь есть у всех строк. 32 \nПоддержка указанных в NIST FIPS 202 алгоритмов хеширования SHA-3, кроме SHAKE128 и SHAKE256. Алгоритмы использования SHA-3 в качестве основы для других криптографических функций не реализованы в силу отсутствия соответствующих стандартов 33 .\nУлучшены средства для пометки устаревшего API. В аннотацию @Deprecated добавлен параметр, позволяющий указывать версию программы, с которой использование отмеченного элемента не рекомендуется, а также — параметр, позволяющий указать, что запланировано удаление элемента в какой-либо из будущих версий 34 .\nПоддержка GTK+ 3 на Linux 35 .\nJava SE 10\nДата релиза: 20 марта 2018 года. 36 \n\nСписок нововведений\nОфициальный частичный список нововведений и план релиза расположен на сайте OpenJDK.\n\nВывод типов локальных переменных, помеченных с помощью ключевого слова var 37 .\nСоздание прозрачного интерфейса сборщика мусора для упрощения разработки новых сборщиков 38 .\nУменьшено время задержек многопоточного сборщика мусора G1 за счёт реализации параллельного полного цикла сборки мусора 39 .\nВозможность выполнять функции обратного вызова на потоках, не делая глобальных блокировок 40  в рамках всех потоков 41 .\nПоддержка символов из новых расширений Unicode: cu (тип валюты), fw (первый день недели), rg (двухбуквенные коды стран и регионов), tz (часовой пояс) 42 .\nHotSpot VM теперь может выделять память кучи для объектов на альтернативных устройствах оперативной памяти, в том числе тех, которые обладают энергонезависимой памятью, как, например, накопители Intel Optane Memory 43 .\nНовый экспериментальный JIT-компилятор Graal, предоставляющий возможности Ahead-of-Time компиляции; по умолчанию отключён, работает только на Linux/x64 44 .\nОбновление системы нумерации версий Java SE и JDK с целью приближения к схеме управления версиями по времени 45 .\nJava SE 11\nОфициальный частичный список нововведений и план релиза расположен на сайте OpenJDK. Дата релиза — 25 сентября 2018 года.\n\nСписок нововведений\nОбновление системы управления доступом, позволяющее вложенным классам обращаться к закрытым (private) методам и полям внешнего класса (и наоборот) без необходимости создания компилятором промежуточных методов с повышением уровня доступа 46 .\nEpsilon — новый сборщик мусора, собственно сборкой мусора не занимающийся вообще; при использовании Epsilon превышение предела выделяемой памяти приводит к завершении работы JVM 47 .\nСтандартизирован клиент HTTP с поддержкой HTTP/2, введённый в Java 9 как экспериментальный 48 .\nПараметры лямбда-функций могут быть неявно типизированы путём вывода типов через ключевое слово (var) для унификации с синтаксисом локальных переменных, введённым в JDK 10 49 .\nПоддержка 10-й версии стандарта Unicode 50 .\nПоддержка протокола TLS 1.3 51 .\nЭкспериментальный масштабируемый сборщик мусора ZGC с низкими задержками. По умолчанию отключён, работает только на Linux/x64 52 .\nКлассификация платформ Java\nВнутри Java существует несколько основных семейств технологий:\n\nJava SE — Java Standard Edition, основное издание Java, содержит компиляторы, API, Java Runtime Environment; подходит для создания пользовательских приложений, в первую очередь — для настольных систем.\nJava EE — Java Enterprise Edition, представляет собой набор спецификаций для создания программного обеспечения уровня предприятия. В 2017-м проект Java EE был передан Eclipse Foundation 53 , после чего был переименован в Jakarta EE 54 . Модули Java EE удалены из Java SE, начиная с 11-й версии 55 .\nJava ME — Java Micro Edition, создана для использования в устройствах, ограниченных по вычислительной мощности, например, в мобильных телефонах, КПК, встроенных системах;\nJava Card — технология предоставляет безопасную среду для приложений, работающих на смарт-картах и других устройствах с очень ограниченным объёмом памяти и возможностями обработки.\nJava и Microsoft\nКомпанией Microsoft была разработана собственная реализация JVM под названием Microsoft Java Virtual Machine (англ.)русск. (MSJVM) 56 , включавшаяся в состав различных операционных систем, начиная с Windows 98 (также входила в Internet Explorer от версии 3 и выше, что позволяло использовать MSJVM в ОС Windows 95 и Windows NT 4 после установки IE3+ на данные ОС).\nMSJVM имела существенные отличия от Sun Java, во многом ломающие основополагающую концепцию переносимости программ между разными платформами:\n\nотсутствие поддержки программного интерфейса вызова удалённых методов (RMI);\nотсутствие поддержки технологии JNI;\nналичие нестандартных расширений, таких, как средства интеграции Java и DCOM, работающих только на платформе Windows.\nТесная интеграция Java с DCOM и Win32 поставила под вопрос кроссплатформенную парадигму языка. Впоследствии это явилось поводом для судебных исков со стороны Sun Microsystems к Microsoft. Суд принял сторону компании Sun Microsystems. В конечном счёте между двумя компаниями была достигнута договорённость о возможности продления срока официальной поддержки пользователей нестандартной Microsoft JVM до конца 2007 года 56 .\nВ 2005 году компанией Microsoft для платформы .NET был представлен Java-подобный язык J#, не соответствующий официальной спецификации языка Java и исключённый впоследствии из стандартного инструментария разработчика Microsoft Visual Studio, начиная с Visual Studio 2008 57 .\n\nJava и Android\nОсновная статья: Android\nЯзык Java активно используется для создания мобильных приложений под операционную систему Android. При этом программы компилируются в нестандартный байт-код, для использования их виртуальной машиной Dalvik (начиная с Android 5.0 Lollipop виртуальная машина заменена на ART). Для такой компиляции используется дополнительный инструмент, а именно Android SDK (Software Development Kit), разработанный компанией Google.\nРазработку приложений можно вести в среде Android Studio, NetBeans, в среде Eclipse, используя при этом плагин Android Development Tools (ADT), или в IntelliJ IDEA. Версия JDK при этом должна быть 5.0 или выше.\n8 декабря 2014 года Android Studio признана компанией Google официальной средой разработки под ОС Android.\n\nПрименения платформы Java\nСледующие успешные проекты реализованы с привлечением Java (J2EE) технологий: RuneScape, Amazon 58  59 , eBay 60  61 , LinkedIn 62 , Yahoo! 63 .\nСледующие компании в основном фокусируются на Java (J2EE) технологиях: SAP, IBM, Oracle. В частности, СУБД Oracle Database включает JVM как свою составную часть, обеспечивающую возможность непосредственного программирования СУБД на языке Java, включая, например, хранимые процедуры 64 .\n\nПроизводительность\nПрограммы, написанные на Java, имеют репутацию более медленных и занимающих больше оперативной памяти, чем написанные на языке C 5 . Тем не менее, скорость выполнения программ, написанных на языке Java, была существенно улучшена с выпуском в 1997—1998 годах так называемого JIT-компилятора в версии 1.1 в дополнение к другим особенностям языка для поддержки лучшего анализа кода (такие, как внутренние классы, класс StringBuffer док. 5 , упрощённые логические вычисления и так далее). Кроме того, была произведена оптимизация виртуальной машины Java — с 2000 года для этого используется виртуальная машина HotSpot. По состоянию на февраль 2012 года, код Java 7 приблизительно в 1,8 раза медленнее кода, написанного на языке Си 65 .\nНекоторые платформы предлагают аппаратную поддержку выполнения для Java 66 . К примеру, микроконтроллеры, выполняющие код Java на аппаратном обеспечении вместо программной JVM, а также основанные на ARM процессоры, которые поддерживают выполнение байткода Java через опцию Jazelle.\n\nОсновные возможности\nАвтоматическое управление памятью.\nРасширенные возможности обработки исключительных ситуаций.\nБогатый набор средств фильтрации ввода-вывода.\nНабор стандартных коллекций: массив, список, стек и т. п.\nНаличие простых средств создания сетевых приложений (в том числе с использованием протокола RMI).\nНаличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы.\nВстроенные в язык средства создания многопоточных приложений, которые потом были портированы на многие языки (например Python).\nУнифицированный доступ к базам данных:\nна уровне отдельных SQL-запросов — на основе JDBC, SQLJ;\nна уровне концепции объектов, обладающих способностью к хранению в базе данных — на основе Java Data Objects (англ.) и Java Persistence API.\nПоддержка обобщений (начиная с версии 1.5).\nПоддержка лямбд, замыканий, встроенные возможности функционального программирования (с 1.8).\nОсновные идеи\nПримитивные типы\nВ языке Java только 8 примитивных (скалярных, простых) типов: boolean, byte, char, short, int, long, float, double. Существует также вспомогательный девятый примитивный тип — void, однако переменные и поля такого типа не могут быть объявлены в коде, а сам тип используется только для описания соответствующего ему класса, для использования при рефлексии: например, с помощью класса Void док. 6  можно узнать, является ли определённый метод типа void: Hello.class.getMethod(\"main\", String[].class).getReturnType() == Void.TYPE.\nДлины и диапазоны значений примитивных типов определяются стандартом, а не реализацией, и приведены в таблице. Тип char сделали двухбайтовым для удобства локализации (один из идеологических принципов Java): когда складывался стандарт, уже существовал Unicode-16, но не Unicode-32. Поскольку в результате не осталось однобайтового типа, добавили новый тип byte, причём в Java, в отличие от других языков, он не является беззнаковым. Типы float и double могут иметь специальные значения \n  \n    \n      \n        +\n         \n      \n    \n    {\\displaystyle +\\infty }\n  \n, \n  \n    \n      \n         \n         \n      \n    \n    {\\displaystyle -\\infty }\n  \n и «не число» (NaN). Для типа double они обозначаются Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN; для типа float — так же, но с приставкой Float вместо Double. Минимальные и максимальные значения, принимаемые типами float и double, тоже стандартизованы.\n\n\n\nТип\n\nДлина (в байтах)\nДиапазон или набор значений\n\n\nboolean\n1 в массивах, 4 в переменных 67 \ntrue, false\n\n\nbyte\n1\n−128..127\n\n\nchar\n2\n0..216−1, или 0..65535\n\n\nshort\n2\n−215..215−1, или −32768..32767\n\n\nint\n4\n−231..231−1, или −2147483648..2147483647\n\n\nlong\n8\n−263..263−1, или примерно −9.2·1018..9.2·1018\n\n\n\nfloat\n4\n-(2-2−23)·2127..(2-2−23)·2127, или примерно −3.4·1038..3.4·1038, а также \n  \n    \n      \n         \n         \n      \n    \n    {\\displaystyle -\\infty }\n  \n, \n  \n    \n      \n         \n      \n    \n    {\\displaystyle \\infty }\n  \n, NaN\n\n\ndouble\n8\n-(2-2−52)·21023..(2-2−52)·21023, или примерно −1.8·10308..1.8·10308, а также \n  \n    \n      \n         \n         \n      \n    \n    {\\displaystyle -\\infty }\n  \n, \n  \n    \n      \n         \n      \n    \n    {\\displaystyle \\infty }\n  \n, NaN\n\nТакая жёсткая стандартизация была необходима, чтобы сделать язык платформенно-независимым, что является одним из идеологических требований к Java. Тем не менее, одна небольшая проблема с платформенной независимостью всё же осталась. Некоторые процессоры используют для промежуточного хранения результатов 10-байтовые регистры или другими способами улучшают точность вычислений. Для того, чтобы сделать Java максимально совместимой между разными системами, в ранних версиях любые способы повышения точности вычислений были запрещены. Однако это приводило к снижению быстродействия. Выяснилось, что ухудшение точности ради платформенной независимости мало кому нужно, тем более если за это приходится платить замедлением работы программ. После многочисленных протестов этот запрет отменили, но добавили ключевое слово strictfp, запрещающее повышение точности.\n\nПреобразования при математических операциях\nВ языке Java действуют следующие правила:\n\nЕсли один операнд имеет тип double, другой тоже преобразуется к типу double.\nИначе, если один операнд имеет тип float, другой тоже преобразуется к типу float.\nИначе, если один операнд имеет тип long, другой тоже преобразуется к типу long.\nИначе оба операнда преобразуются к типу int.\nДанный способ неявного преобразования встроенных типов полностью совпадает с преобразованием типов в Си/C++ 68 .\n\nОбъектные переменные, объекты, ссылки и указатели\nВ языке Java имеются только динамически создаваемые объекты. Переменные объектного типа и объекты в Java — совершенно разные сущности. Переменные объектного типа являются ссылками, то есть аналогами указателей на динамически создаваемые объекты. Это подчёркивается синтаксисом описания переменных. Так, код на C++ может выглядеть следующим образом:\n\ndouble a[10][20];\nFoo b(30);\n\nНо то же самое на Java будет выглядеть совсем по-другому:\n\ndouble[][] a = new double[10][20];\nFoo b = new Foo(30);\n\nПри присваиваниях, передаче в подпрограммы и сравнениях объектные переменные ведут себя как указатели, то есть присваиваются, копируются и сравниваются адреса объектов. А при доступе с помощью объектной переменной к полям данных или методам объекта не требуется никаких специальных операций разыменовывания — этот доступ осуществляется так, как если бы объектная переменная была самим объектом.\nОбъектными являются переменные любого типа, кроме примитивного. Явных указателей в Java нет. В отличие от указателей C, C++ и других языков программирования, ссылки в Java в высокой степени безопасны благодаря жёстким ограничениям на их использование.\n\nНельзя преобразовывать объект типа int или любого другого примитивного типа в указатель или ссылку и наоборот.\nНад ссылками запрещено выполнять операции ++, −−, +, − или любые другие арифметические операции.\nПреобразование типов между ссылками жёстко регламентировано. За исключением ссылок на массивы, разрешено преобразовывать ссылки только между наследуемым типом и его наследником, причём преобразование наследуемого типа в наследующий должно быть явно задано, а во время выполнения производится проверка его осмысленности. Преобразования ссылок на массивы разрешены лишь тогда, когда разрешены преобразования их базовых типов, а также нет конфликтов размерности.\nВ Java нет операций взятия адреса (&amp;) или взятия объекта по адресу (*). Амперсанд (&amp;) означает всего лишь «побитовое и» (двойной амперсанд — «логическое и»). Однако для булевых типов одиночный амперсанд означает «логическое и», отличающееся от двойного тем, что цепь проверок не прекращается при получении в выражении значения false 69 . Например, a == b &amp;&amp; foo() == bar() не повлечёт вызовов foo() и bar() в случае, если a != b, тогда как использование &amp; — повлечёт в любом случае.\nБлагодаря таким специально введённым ограничениям в Java невозможно прямое манипулирование памятью на уровне физических адресов (хотя определено значение ссылки, не указывающей ни на что: null).\nЕсли нужен указатель на примитивный тип, используются классы-обёртки примитивных типов: Boolean, Byte, Character, Short, Integer, Long, Float, Double.\n\nДублирование ссылок и клонирование\nИз-за того, что объектные переменные являются ссылочными, при присваивании не происходит копирования объекта. Так, если написать\n\nFoo foo, bar;\n…\nbar = foo;\n\nто произойдёт копирование адреса из переменной foo в переменную bar. То есть foo и bar будут указывать на одну и ту же область памяти, то есть на один и тот же объект; попытка изменить поля объекта, на который ссылается переменная foo, будет менять объект, с которым связана переменная bar, и наоборот. Если же необходимо получить именно ещё одну копию исходного объекта, пользуются или методом (функцией-членом, в терминологии C++) clone (), создающим копию объекта, или (реже) копирующим конструктором (конструкторы в Java не могут быть виртуальными, поэтому экземпляр класса-потомка будет неправильно скопирован конструктором класса-предка; метод клонирования вызывает нужный конструктор и тем самым позволяет обойти это ограничение).\nМетод clone() док. 7  требует, чтобы класс реализовывал интерфейс Cloneable док. 8 . Если класс реализует интерфейс Cloneable, по умолчанию clone() копирует все поля (мелкая копия). Если требуется не копировать, а клонировать поля (а также их поля и так далее), надо переопределять метод clone(). Определение и использование метода clone() часто является нетривиальной задачей 70 .\n\nИнициализация переменных\nВсе переменные или требуют явного определения, или автоматически заполняются нулями (0, null, массивом нулей). Таким образом, исчезают гейзенбаги, связанные со случайным использованием неинициализированной памяти, характерные для низкоуровневых языков вроде Си.\n\nСборка мусора\nВ языке Java невозможно явное удаление объекта из памяти — вместо этого реализована сборка мусора. Традиционным приёмом, дающим сборщику мусора «намёк» на необходимость освобождения памяти, является присваивание переменной пустого значения null, что может оказаться эффективным при необходимости освободить более не требующийся объект, ссылка на который хранится в долгоживущем объекте 71 . Это, однако, не значит, что объект, заменённый значением null, будет непременно и немедленно удалён, но есть гарантия, что этот объект будет удалён именно в будущем. Данный приём всего лишь устраняет ссылку на объект, то есть отвязывает указатель от объекта в памяти. При этом следует учитывать, что объект не будет удалён сборщиком мусора, пока на него указывает хотя бы одна ссылка из используемых переменных или объектов. Существуют также методы для инициации принудительной сборки мусора, но не гарантируется, что они будут вызваны исполняющей средой, и их не рекомендуется использовать для обычной работы.\n\nКлассы и функции\nJava не является процедурным языком: любая функция может существовать только внутри класса. Это подчёркивает терминология языка Java, где нет понятий «функция» или «функция-член» (англ. member function), а только метод. В методы превратились и стандартные функции. Например, в Java нет функции sin(), а есть метод Math.sin() класса Math (содержащего, кроме sin(), методы cos(), exp(), sqrt(), abs() и многие другие). Конструкторы в Java не считаются методами. Деструкторов в Java не существует, а метод finalize() ни в коем случае нельзя считать аналогом деструктора.\n\nКонструкторы\nКонструктор — это специальный метод, который обязательно вызывается при создании нового объекта, то есть объект (экземпляр класса) не может быть создан без вызова конструктора класса. Не всегда удобно инициализировать все переменные класса при создании его экземпляра, поэтому переменные экземпляра часто объявляют внутри тела конструктора, а инициализируют как аргументы конструктора при создании экземпляра класса. Иногда проще, чтобы какие-то значения были бы созданы по умолчанию при создании объекта. В таком случае переменные объявляются и инициализируются внутри тела конструктора.\n\nКонструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.private int Cat();  // так выглядит метод по имени Cat\nCat();              // так выглядит конструктор класса Cat\nВ отличие от метода, конструктор никогда ничего не возвращает.\nКонструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса. Как правило, программисты стараются явно указать конструктор. Если явного конструктора нет, то Java автоматически создаст его (пустым) для использования по умолчанию.\n\nВ качестве примера можно рассмотреть некий класс Box, представляющий собой описание коробки. Конструктор класса просто установит начальные размеры для коробки.class Box {\n    int width; // ширина коробки\n    int height; // высота коробки\n    int depth; // глубина коробки\n\t\n    // Конструктор\n    Box(int a, int b) {\n        width = a;\n        height = b;\n        depth = 10;\n    }\n\n    // вычисляем объём коробки\n    int getVolume() {\n    \treturn width * height * depth;\n    }\n}\n\nСтатические методы и поля\nВ Java (как и в C++) используются статические поля и статические методы (англ. static method — в теории программирования их также называют методами класса), которые задаются при помощи ключевого слова static. Статические поля (переменные класса) имеют тот же смысл, что и в C++: каждое такое поле является собственностью класса, поэтому для доступа к статическим полям не требуется создавать экземпляры соответствующего класса.\nНапример, математические функции, реализованные в классе Math док. 9 , представляют собой как раз статические методы данного класса. Поэтому их можно вызывать напрямую из класса, не создавая его экземпляра, например:\n\ndouble x = Math.sin(1);\n\nСоздание экземпляра статического класса запрещают с помощью приватного конструктора. Например, создание экземпляра класса Math приведёт к ошибке на этапе компиляции:\n\nMath m = new Math(); // Error: Math() has private access in java.lang.Math\ndouble x = m.sin(1); // Метода sin у объекта не существовало бы, т. к. он статичный\n\nПоскольку статические методы существуют независимо от объектов (экземпляров класса), они не имеют доступа к обычным (не статическим) полям и методам данного класса. В частности, при реализации статического метода недопустимо использовать идентификатор this.\nВозможность статического импорта позволяет вызывать статические функции и константы без указания класса. Пример без статического импорта:\n\ndouble x = Math.sin(Math.tan(Math.sqrt(y)) + Math.floor(24.5)) + Math.cos(42 * Math.PI);\n\nТот же пример, но со статическим импортом:\n\nimport static java.lang.Math.*;\n...\ndouble x = sin(tan(sqrt(y)) + floor(24.5)) + cos(42 * PI);\n\nЗавершённость (final)\nКлючевое слово final (финальный) имеет разные значения при описании поля, метода или класса.\n\nФинальное поле класса инициализируется при описании или в конструкторе класса (а статическое поле — в статическом блоке инициализации). Впоследствии его значение не может быть изменено. Если статическое поле класса или переменная проинициализированы константным выражением, они рассматриваются компилятором как именованная константа; в таком случае их значение может быть использовано в операторах switch (для констант типа int), а также для условной компиляции (для констант типа boolean) при использовании с оператором if.\nЗначения локальных переменных, а также параметров метода, помеченных ключевым словом final, не могут быть изменены после присвоения. При этом их значения могут использоваться внутри анонимных классов.\nМетод класса, отмеченный словом final, не может быть переопределён при наследовании.\nФинальный класс не может иметь наследников.\nАбстрактность\nВ Java методы, не объявленные явно как static, final или private, являются виртуальными в терминологии C++: при вызове метода, по-разному определённого в базовом и наследующем классах, всегда производится проверка времени выполнения.\nАбстрактным методом (модификатор abstract) в Java называется метод, для которого заданы параметры и тип возвращаемого значения, но не задано тело. Абстрактный метод определяется в классах-наследниках. Аналог абстрактного метода в C++ — чисто виртуальная функция (pure virtual function). Для того чтобы в классе можно было описывать абстрактные методы, сам класс тоже должен быть описан как абстрактный. Объекты абстрактного класса создавать нельзя.\n\nИнтерфейсы\nВысшей степенью абстрактности в Java является интерфейс (модификатор interface). Все методы интерфейса абстрактны: описатель abstract даже не требуется. Интерфейс в Java не считается классом, хотя, по сути, является полностью абстрактным классом. Класс может наследовать/расширять (extends) другой класс или реализовывать (implements) интерфейс. Кроме того, интерфейс может наследовать/расширять другой интерфейс.\nВ Java класс не может наследовать более одного класса, зато может реализовывать несколько интерфейсов. Множественное наследование интерфейсов не запрещено, то есть один интерфейс может наследоваться от нескольких.\nИнтерфейсы можно использовать в качестве типов параметров методов. Нельзя создавать экземпляры интерфейсов.\n\nМаркерные интерфейсы\nВ Java есть интерфейсы, которые не содержат методов для реализации, а специальным образом обрабатываются JVM: Cloneable, Serializable, RandomAccess, Remote.\n\nШаблоны в Java (generics)\n\nНачиная с версии Java 5.0 в языке появился механизм обобщённого программирования — шаблоны, внешне близкие к шаблонам C++. С помощью специального синтаксиса в описании классов и методов можно указать параметры-типы, которые внутри описания могут использоваться в качестве типов полей, параметров и возвращаемых значений методов.\n\n// Объявление обобщённого класса\nclass GenericClass&lt;E&gt; {\n  E getFirst() { ... }\n  void add(E obj) { ... }\n}\n\n// Использование обобщённого класса в коде\nGenericClass&lt;String&gt; obj = new GenericClass&lt;&gt;();\nobj.add(&quot;qwerty&quot;);\nString p = obj.getFirst();\n\nДопускается обобщённое объявление классов, интерфейсов и методов. Кроме того, синтаксис поддерживает ограниченные объявления типов-параметров: указание в объявлении конструкции вида &lt;T extends A &amp; B &amp; C...&gt; требует, чтобы тип-параметр T реализовывал интерфейсы A, B, C и так далее.\nВ отличие от шаблонов C#, шаблоны Java не поддерживаются средой исполнения — компилятор просто создаёт байт-код, в котором никаких шаблонов уже нет. Реализация шаблонов в Java принципиально отличается от реализации аналогичных механизмов в C++: компилятор не порождает для каждого случая использования шаблона отдельный вариант класса или метода-шаблона, а просто создаёт одну реализацию байт-кода, содержащую необходимые проверки и преобразования типов. Это приводит к ряду ограничений использования шаблонов в программах на Java.\n\nПроверка принадлежности к классу\nВ Java можно явно проверить, к какому классу принадлежит объект. Выражение foo instanceof Foo истинно, если объект foo принадлежит классу Foo или его наследнику, или реализует интерфейс Foo (или, в общем виде, наследует класс, который реализует интерфейс, который наследует Foo).\nДалее функция getClass() док. 10 , определённая для всех объектов, выдаёт объект типа Class. Для каждого класса создаётся не более одного описывающего его объекта типа Class, поэтому эти объекты можно сравнивать. Так, например, foo.getClass() == bar.getClass() будет истинно, если объекты foo и bar принадлежат к одному классу.\nКроме того, объект типа Class любого типа можно получить так: Integer.class, Object.class.\nПрямое сравнение классов не всегда является оптимальным средством проверки на принадлежность к классу. Зачастую вместо него используют функцию isAssignableFrom(). Эта функция определена у объекта типа Class и принимает объект типа Class в качестве параметра. Таким образом, вызов Foo.class.isAssignableFrom(Bar.class) вернёт true в случае, если Foo является предком класса Bar. Так как все объекты являются потомками типа Object, вызов Object.class.isAssignableFrom() всегда вернёт true.\nВ паре с упомянутыми функциями объекта типа Class используются также функции isInstance док. 11  (эквивалентно instanceof), а также cast() (преобразует параметр в объект выбранного класса).\n\nОбработка ошибок\nОбработка ошибок в Java похожа на обработку ошибок в C++, за исключением необходимости в блоке finally. Данное отличие обусловлено тем, что Java не может придерживаться концепции RAII из-за наличия сборщика мусора, а автоматическое освобождение ресурсов в деструкторе может идти в непредсказуемом порядке через произвольные промежутки времени.\nОсуществляется обработка ошибок с помощью операторов try, catch и finally. Выбрасываемая ошибка описывается объектом определённого класса, реализующего интерфейс Throwable док. 12  и соответствующего типу ошибки. Внутрь блока try помещается код, который может выбросить исключение, а блок catch отлавливает заданные программистом типы ошибок. При этом можно указывать более одного блока catch для обработки различных классов ошибок. Блок finally выполняется независимо от возникновения ошибки и предназначен для освобождения выделенных в ходе работы блока try ресурсов.\nНачиная с Java 7 поддерживается интерфейс AutoClosable док. 13 , который позволяет реализовывать классы, автоматически освобождающие ресурсы. Объекты подобных классов требуется создавать в круглых скобках перед блоком try. Простым примером автоматического освобождения ресурсом может служить чтение содержимого файла:\n\n 1 import java.io.*;\n 2 \n 3 public class Main {\n 4     public static void main(String[] args) throws IOException {\n 5         if (args.length &lt; 2) {\n 6             System.err.println(&quot;Не указано имя файла.&quot;);\n 7             return;\n 8         }\n 9         String filename = args[1];\n10         // Открытый файл будет автоматически закрыт по ошибке\n11         try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {\n12             String line;\n13             for (int n = 1; (line = reader.readLine()) != null; ++n) {\n14                 System.out.println(n + &quot;: &quot; + line);\n15             }\n16         } catch (FileNotFoundException e) {\n17             System.err.println(&quot;Указанный файл не найден.&quot;);\n18         }\n19     }\n20 }\n\nJava придерживается концепции обязательного указания классов ошибок, которые может выбросить метод. Делается это с помощью ключевого слово throws после описания метода. Если в методе не указать класс исключения (или его предка), которое может быть выброшено из метода, то это вызовет ошибку компиляции. Концепция должна была позволить делать код самодокументируемым, обозначая, какие исключения может выбросить тот или иной метод, но на практике редко себя оправдывает, поскольку в силу разных обстоятельств программист может указать в качестве выбрасываемого исключения класс Exception, либо заключить проблемные части метода в блок try…catch для игнорирования отдельных ошибок, либо — в блок try…finally, скрывая все возможные ошибки. Недостатком концепции также является и то, что программист сам должен определять и прописывать исключения, которые может выбрасывать метод 72 .\n\nПространство имён\nОсновная статья: Пространство имён (программирование)\nИдея пространств имён воплощена в Java-пакетах.\nВнутри пакета есть два независимых пространства имен: переменные и методы.\n\nПримеры программ\nКод программы «Hello World!».\n\n1 class HelloWorld {\n2     public static void main(String[] args) {\n3         System.out.println(&quot;Hello World!&quot;);\n4     }\n5 }\n\nОбобщения:\n\nПример использования обобщений\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class Sample {\n    public static void main(String[] args) {\n        // Создание объекта по шаблону.\n        List&lt;String&gt; strings = new ArrayList&lt;&gt;();\n        strings.add(&quot;Hello&quot;);\n        strings.add(&quot;world&quot;);\n        strings.add(&quot;!&quot;);\n        for (var string : strings) {\n            System.out.print(string + &quot; &quot;);\n        }\n    }\n}\n\n\nРефлексия:\n\nПример использования рефлексии\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\nclass TestClass {\n    private int value;\n    public int getValue() { return value; }\n    public void setValue(int valueIn) { this.value = valueIn; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        var testClass = new TestClass();\n\n        for (var field: testClass.getClass().getDeclaredFields()) {\n            System.out.printf(&quot;name:%s, type:%s \\n&quot;, field.getName(), field.getType().getCanonicalName());\n        }\n\n        for (var method : testClass.getClass().getDeclaredMethods()) {\n            System.out.printf(&quot;name:%s, return type:%s  \\n&quot;, method.getName(), method.getReturnType().getCanonicalName());\n        }        \n    }\n}\n\n\nАннотации:\n\nПример использования аннотаций\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface MyAnnotation {\n\n    public boolean value() default false;\n\n}\n\n@MyAnnotation(value=true)\npublic class TestClass {\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        var testClass = new TestClass();\n\n        var myAnnotation = testClass.getClass().getAnnotation(MyAnnotation.class);\n        if (myAnnotation != null) {\n            System.out.printf(&quot;value:%s \\n&quot;, myAnnotation.value());\n        }\n    }\n}\n\n\nСредства разработки ПО\nJDK — помимо набора библиотек для платформ Java SE и Java EE, содержит компилятор командной строки javac и набор утилит, также работающих в режиме командной строки.\nNetBeans IDE — свободная интегрированная среда разработки для всех платформ Java — Java ME, Java SE и Java EE. Пропагандируется Oracle, владельцем технологии Java, как базовое средство для разработки ПО на языке Java и других языках (C, C++, PHP, Fortran и др.).\nEclipse IDE — свободная интегрированная среда разработки для Java SE, Java EE и Java ME 73 . Пропагандируется IBM, одним из важнейших разработчиков корпоративного ПО, как базовое средство для разработки ПО на языке Java и других языках (C, C++, Ruby, Fortran и др.).\nIntelliJ IDEA — среда разработки для платформ Java SE, Java EE и Java ME. Разработчик — компания JetBrains. Распространяется в двух версиях: свободной бесплатной (Community Edition) и коммерческой проприетарной (Ultimate Edition).\nJDeveloper — среда разработки для платформ Java SE, Java EE и Java ME. Разработчик — компания Oracle.\nBlueJ — среда разработки программного обеспечения на языке Java, созданная в основном для использования в обучении, но также подходящая для разработки небольших программ.\nGeany — свободная среда разработки программного обеспечения, написанная с использованием библиотеки GTK2.\nСм. также\n.mw-parser-output .ts-Родственные_проекты{width:19em;box-sizing:border-box;margin:0 0 .5em 1em;padding:.4em;background:#f8f9fa;border:1px solid #a2a9b1;font-size:90%}.mw-parser-output .ts-Родственные_проекты-header{margin-bottom:.2em;padding:.2em .6em;font-size:110%}.mw-parser-output .ts-Родственные_проекты ul li{display:flex;padding:.2em .6em}.mw-parser-output .ts-Родственные_проекты ul li .image{min-width:24px;display:inline-block;margin-right:.4em;flex:none;vertical-align:top;text-align:center}.mw-parser-output .ts-Родственные_проекты ul li .image img{vertical-align:middle}.mw-parser-output .ts-Родственные_проекты ul li .label{align-self:center}.mw-parser-output .ts-Родственные_проекты ul li hr{width:100%;margin:0}@media(max-width:719px){.mw-parser-output .ts-Родственные_проекты{width:auto;margin-left:0;margin-right:0}}В родственных проектахЗначения в ВикисловареКниги в ВикиучебникеМедиафайлы на Викискладе\nСравнение C# и Java\nСписок Java API\nJava User Groups\nПримечания\nКомментарии\n\n\n↑ Произносится на английском как /ˈdʒɑːvə/, в русском языке встречаются транслитерации «Джава» и «Ява», правообладатели торговой марки предпочитают первую транслитерацию.\n\n\nДокументация\n\n\n↑ String\n\n↑ AutoCloseable\n\n↑ URLClassLoader\n\n↑ HttpURLConnection\n\n↑ StringBuffer\n\n↑ Void\n\n↑ clone()\n\n↑ Cloneable\n\n↑ Math\n\n↑ getClass()\n\n↑ isInstance()\n\n↑ Throwable\n\n↑ AutoCloseable\n\n\nИсточники\n\n\n↑ https://www.oracle.com/corporate/pressrelease/Java-10-032018.html\n\n↑ The 2018 Top Programming Languages (англ.), IEEE Spectrum: Technology, Engineering, and Science News. Дата обращения 19 ноября 2018.\n\n↑ TIOBE Index | TIOBE - The Software Quality Company (неопр.).  www.tiobe.com. Дата обращения 19 ноября 2018.\n\n↑ Buyya. Object-oriented Programming with Java: Essentials and Applications. — Tata McGraw-Hill Education, 2009. — 678 с. — ISBN 9780070669086.\n\n↑ 1 2 Java 6 -server speed ÷ C++ GNU g++ speed | Computer Language Benchmarks Game (неопр.) (недоступная ссылка). Дата обращения 4 марта 2010. Архивировано 14 июня 2011 года.\n\n↑ Metz, Cade. Google pits C++ against Java, Scala, and Go (англ.).  The Register (3 June 2011). Дата обращения 5 июня 2011. Архивировано 21 августа 2011 года.\n\n↑ Loop Recognition in C++/Java/Go/Scala (PDF, 0.3 МБ)\n\n↑ В Google провели сравнение производительности C++, Java, Go и Scala\n\n↑ Robert Tolksdorf. Programming languages for the Java Virtual Machine JVM (англ.).  is-research GmbH. — Онлайн-каталог альтернативных языков и языковых расширений для JVM. Дата обращения 5 июня 2009. Архивировано 21 августа 2011 года.\n\n↑ SUN SHIPS JDK 1.1 -- JAVABEANS INCLUDED (неопр.) (10 февраля 2008). Дата обращения 17 ноября 2018.\n\n↑ Java 2 Software (неопр.) (19 января 2004). Дата обращения 17 ноября 2018.\n\n↑ Ada 83 LRM, Sec 12.1: Generic Declarations (неопр.).  archive.adaic.com. Дата обращения 17 ноября 2018.\n\n↑ Результаты тестов\n\n↑ JavaFX FAQ (неопр.).  www.oracle.com. Дата обращения 17 ноября 2018.\n\n↑ Smith, Donald. The Future of JavaFX and Other Java Client Roadmap Updates. Дата обращения 17 ноября 2018.\n\n↑ план разработки для JDK7\n\n↑ План Б\n\n↑ OpenJDK: Project Coin (неопр.).  openjdk.java.net. Дата обращения 17 ноября 2018.\n\n↑ Компания Oracle анонсировала выход Java Standard Edition 7 (рус.)\n\n↑ Index corruption and crashes in Apache Lucene Core / Apache Solr with Java 7 (англ.)\n\n↑ Акторное расширение языка Java в среде MPS. — вестник ИТМО. — Вып 6 (94)\n\n↑ What's New in JDK 8 (неопр.).  www.oracle.com. Дата обращения 17 ноября 2018.\n\n↑ Method References (англ.). The Java™ Tutorials.  docs.oracle.com. Дата обращения 17 ноября 2018.\n\n↑ JDK 9 release delayed another four months\n\n↑ Java 9 gets a release date: July 27\n\n↑ Java 9 delayed to September 21\n\n↑ Oracle Announces Java SE 9 and Java EE 8. Press Release (англ.). Oracle (Sep 21, 2017). Дата обращения 1 августа 2018.\n\n↑ Project Jigsaw (англ.).  openjdk.java.net. Дата обращения 24 ноября 2018.\n\n↑ JEP 102: Process API Updates (англ.). OpenJDK.\n\n↑ 1 2 JEP 110: HTTP/2 Client (Incubator) (англ.). OpenJDK.\n\n↑ JEP 11: Incubator Modules (англ.). OpenJDK.\n\n↑ JEP 254: Compact Strings (англ.). OpenJDK.\n\n↑ JEP 287: SHA-3 Hash Algorithms (англ.). OpenJDK.\n\n↑ JEP 277: Enhanced Deprecation (англ.). OpenJDK.\n\n↑ JEP 283: Enable GTK 3 on Linux (неопр.).  openjdk.java.net. Дата обращения 25 ноября 2018.\n\n↑ Oracle Java SE 10 Release Arrives (англ.).  ORACLE. Дата обращения 24 июня 2018. Архивировано 20 марта 2018 года.\n\n↑ JEP 286: Local-Variable Type Inference (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 304: Garbage Collector Interface (англ.).  openjdk.java.net. Дата обращения 20 ноября 2018.\n\n↑ JEP 307: Parallel Full GC for G1 (англ.).  openjdk.java.net. Дата обращения 21 ноября 2018.\n\n↑ Алексей Рагозин. Safepoints in HotSpot JVM (англ.).  blog.ragozin.info. Дата обращения 24 ноября 2018.\n\n↑ JEP 312: Thread-Local Handshakes (англ.).  openjdk.java.net. Дата обращения 24 ноября 2018.\n\n↑ JEP 314: Additional Unicode Language-Tag Extensions (англ.).  openjdk.java.net. Дата обращения 22 ноября 2018.\n\n↑ JEP 316: Heap Allocation on Alternative Memory Devices (англ.).  openjdk.java.net. Дата обращения 24 ноября 2018.\n\n↑ JEP 317: Experimental Java-Based JIT Compiler (англ.).  openjdk.java.net. Дата обращения 22 ноября 2018.\n\n↑ JEP 322: Time-Based Release Versioning (англ.).  openjdk.java.net. Дата обращения 22 ноября 2018.\n\n↑ JEP 181: Nest-Based Access Control (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 318: Epsilon: A No-Op Garbage Collector (Experimental) (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 321: HTTP Client (Standard) (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 323: Local-Variable Syntax for Lambda Parameters (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 327: Unicode 10 (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 332: Transport Layer Security (TLS) 1.3 (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) (англ.).  openjdk.java.net. Дата обращения 18 ноября 2018.\n\n↑ Delabassee, David. Opening Up Java EE - An Update. Дата обращения 25 ноября 2018.\n\n↑ And the Name Is… (англ.), Life at Eclipse (26 февраля 2018). Дата обращения 25 ноября 2018.\n\n↑ JEP 320: Remove the Java EE and CORBA Modules (неопр.).  openjdk.java.net. Дата обращения 25 ноября 2018.\n\n↑ 1 2 Microsoft Java Virtual Machine Support (англ.).  Microsoft (12 сентября 2003). — Официальное заявление Microsoft о программе поддержки MSJVM. Дата обращения 9 октября 2010. Архивировано 21 августа 2011 года.\n\n↑ Visual J# (рус.).  Microsoft (ноябрь 2007). — Официальная информация Microsoft об исключении J# из комплекта Visual Studio 2008. Дата обращения 10 октября 2010. Архивировано 21 августа 2011 года.\n\n↑ Todd Hoff. Amazon Architecture (англ.) (18 сентября 2007). — Обсуждение архитектуры Amazon с использованием Java-технологий. Дата обращения 6 июня 2009.\n\n↑ Amazon Elastic Compute Cloud (Amazon EC2) (англ.).  Amazon Web Services LLC. — Описание технологии и возможностей Amazon EC2 как веб-сервиса. Дата обращения 6 июня 2009. Архивировано 21 августа 2011 года.\n\n↑ Todd Hoff. eBay Architecture (англ.) (27 мая 2008). — Обсуждение архитектуры eBay на платформе Java. Дата обращения 6 сентября 2009. Архивировано 21 августа 2011 года.\n\n↑ Randy Shoup, Dan Pritchett. The eBay Architecture (англ.). SD Forum 2006.  ??? (29 ноября 2006). — Презентация по истории развития архитектуры eBay. Дата обращения 6 июня 2009. Архивировано 21 августа 2011 года.\n\n↑ Brian Guan. The LinkedIn Blog. Blog Archive. Grails at LinkedIn (англ.).  LinkedIn.com (11 июня 2008). — История создания системы LinkedIn на основе Java-технологии Grails. Дата обращения 5 июня 2009. Архивировано 21 августа 2011 года.\n\n↑ Hadoop and Distributed Computing at Yahoo! (англ.).  Yahoo!. — Стартовая страница Java-технологии распределённого обслуживания Hadoop на портале разработчиков Yahoo!. Дата обращения 21 июня 2009. Архивировано 21 августа 2011 года.\n\n↑ OracleJVM and Java Stored Procedures (англ.).  Oracle Inc.. — Раздел портала Oracle, посвящённый технологиям Java в составе сервера СУБД Oracle. Дата обращения 5 июня 2009. Архивировано 21 августа 2011 года.\n\n↑ Ubuntu: Intel® Q6600® quad-core Computer Language Benchmarks (неопр.). Архивировано 22 июня 2012 года.\n\n↑ Wolfgang Puffitsch, Martin Schoeberl. picoJava-II in an FPGA (англ.) // DTU Library. — 2007.\n\n↑ JVM не имеет поддержки для переменных типа boolean, поэтому они представляются в виде значений типа int. Однако массивы boolean[] поддерживаются. VM Spec The Structure of the Java Virtual Machine\n\n↑ Бьярн Страуструп. Язык программирования С++   The C++ Programming Language. — М.—СПб.: Бином, Невский диалект, 2008. — 1104 с. — 5000 экз. — ISBN 5-7989-0226-2; ISBN 5-7940-0064-3; ISBN 0-201-70073-5.\n\n↑ Джеймс Гослинг, Билл Джой, Гай Стил, Гилад Брача, Алекс Бакли, Даниел Смит. Java Language Specification. Chapter 15. Expressions (англ.).  docs.oracle.com. Дата обращения 1 декабря 2018.\n\n↑ Java API Reference. Class Object (англ.).  docs.oracle.com. Дата обращения 26 ноября 2018.\n\n↑ Scott Oaks. Java Performance: The Definitive Guide: Getting the Most Out of Your Code. — \"O'Reilly Media, Inc.\", 2014-04-10. — 425 с. — ISBN 9781449363543.\n\n↑ The Trouble with Checked Exceptions (неопр.).  www.artima.com. Дата обращения 21 декабря 2018.\n\n↑ Pulsar - Eclipse Mobile Tools Platform (англ.).  Eclipse. — Проект eclipse для мобильных разработчиков. Дата обращения 23 марта 2011. Архивировано 21 августа 2011 года.\n\n\nЛитература\nГерберт Шилдт. Java. Полное руководство, 10-е издание   Java. The Complete Reference, 10th Edition. — М.: «Диалектика», 2018. — 1488 с. — ISBN 978-5-6040043-6-4.\nКей С. Хорстманн. Java SE 9. Базовый курс   Core Java SE 9 for the Impatient. — М.: «Вильямс», 2018. — 576 с. — ISBN 978-5-6040043-0-2, 978-0-13-469472-6.\nКей С. Хорстманн. Java SE 8. Вводный курс   Java SE 8 for the Really Impatient. — М.: «Вильямс», 2014. — 208 с. — ISBN 978-5-8459-1900-7.\nФрэд Лонг, Дхрув Мохиндра, Роберт С. Сикорд, Дин Ф. Сазерленд, Дэвид Свобода. Руководство для программиста на Java: 75 рекомендаций по написанию надежных и защищённых программ   Java Coding Guidelines: 75 Recommendations for Reliable and Secure Programs. — М.: «Вильямс», 2014. — 256 с. — ISBN 978-5-8459-1897-0.\nКей С. Хорстманн. Java. Библиотека профессионала, том 1. Основы. 10-е издание   Core Java. Volume I - Fundamentals (Tenth Edition). — М.: «Вильямс», 2017. — 864 с. — ISBN 978-5-8459-2084-3.\nКей С. Хорстманн. Java. Библиотека профессионала, том 2. Расширенные средства программирования. 10-е издание   Core Java. Volume II - Advanced Feature (Tenth Edition). — М.: «Вильямс», 2017. — 976 с. — ISBN 978-5-9909445-0-3.\nБарри Берд. Java 9 для чайников   Java For Dummies, 7th edition. — М.: «Диалектика», 2018. — 624 с. — ISBN 978-5-9500296-1-5, 978-1-119-23555-2.\nКишори Шаран. Java 9. Полный обзор нововведений   Java 9 Revealed. — М.: «ДМК Пресс», 2018. — 544 с. — ISBN 978-5-97060-575-2.\nДжеймс Гослинг, Билл Джой, Гай Стил, Гилад Брача, Алекс Бакли. Язык программирования Java SE 8. Подробное описание, 5-е издание   The Java Language Specification, Java SE 8 Edition (5th Edition) (Java Series). — М.: «Вильямс», 2015. — 672 с. — ISBN 978-5-8459-1875-8.\nДжошуа Блох. Java. Эффективное программирование   Effective Java. — 3-е. — М.: Диалектика, 2019. — 464 с. — ISBN 978-5-6041394-4-8.\nБенджамин Дж. Эванс, Джеймс Гоф, Крис Ньюленд. Java: оптимизация программ. Практические методы повышения производительности приложений в JVM. — М.: Диалектика, 2019. — 448 с. — ISBN 978-5-907114-84-5.\nМонахов Вадим. Язык программирования Java и среда NetBeans. — 3-е изд. — СПб.: БХВ-Петербург, 2011. — 704 с. — ISBN 978-5-9775-0671-7.\nБрюс Эккель. Философия Java   Thinking in Java. — 4-е изд. — СПб.: Питер, 2018. — 1168 с. — ISBN 978-5-496-01127-3.\nСсылки\nThe Java Tutorials (англ.) — обучающие материалы по Java 8\nBruce Eckel’s Free Electronic Books (англ.) — свободно распространяемые электронные версии книг Брюса Эккеля по C++ и Java вместе с исходным кодом\nW. Kahan, Joseph D. Darcy. How Java’s Floating-Point Hurts Everyone Everywhere (англ.)\nУчебник Java 8\nJavaПлатформы\nJava Card\nJava ME\nJava SE\nJava EE\nТехнологии Sun\nJava\nJava Development Kit\nOpenJDK\nWTK\nJava Virtual Machine\nJavaFX\nJAXP\nSquawk\nОсновные сторонние технологии\nGNU Classpath\nGNU компилятор для Java\nKaffe\nTopLink\nApache Harmony\nApache Struts\nSpring Framework\nDalvik\nHibernate\nJBoss\nProcessing\nDozer\nAspectJ\nИстория\nИстория версий Java SE\nИстория версий Java EE\nКритика Java\nJava Community Process\nSun Microsystems\nСвободные реализации Java\nСвойства языка\nБайткод\nСинтаксис\nМодель памяти\nАпплеты\nСервлеты\nМидлеты\nJavaServer Pages\nWeb Start\nEnterprise JavaBeans\nСкриптовые языки\nJava Tcl\nJython\nJRuby\nBeanShell\nGroovy\nJudoscript\nSleep\nBean Scripting Framework\nYoix\nRhino\nКонференции Java\nJavaOne\nJoker\nJPoint\n\nЯзыки программированияХронология\nАда\nАссемблер\nAPL\nBASIC\nC\nC++\nC#\nD\nDelphi\nCOBOL\nErlang\nF#\nFortran\nGo\nGroovy\nHaskell\nJava\nJavaScript (JS)\nJulia\nKotlin\nLisp\nLua\nMATLAB\nObjective-C\nOCaml\nPascal\nPerl\nPL/SQL\nPHP\nPowerShell\nPython\nRuby\nRust\nScala\nUNIX Shell\nSmalltalk\nSwift\nTypeScript\nVala\nVisual Basic .NET (VB.NET)\n\n Категория\n Сравнение\n Списки: хронологический\nпо категориям\n\n\n\n\n\n"